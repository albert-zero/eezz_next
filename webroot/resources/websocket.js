/**
 *  Copyright (C) 2015  Albert Zedlitz
 *  
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* Variable declaration generated by agent:
 */
// var g_eezz_socket_addr = "ws://{host}:{port}";
// var g_eezz_arguments   = "{args}";
var g_eezz_web_socket;
window.onload = eezz_connect();

// User Callback Interface
class TEezz {
    constructor() {
        this.on_update  = (a_element) => {};
        this.on_animate = (a_element) => {};
    }
}

// Global user interface instance
eezz = new TEezz();

// Open and controlling the WEB socket
function eezz_connect() {
    console.log('connect websocket ...');
	g_eezz_web_socket        = new WebSocket(g_eezz_socket_addr);
    g_eezz_web_socket.onopen = function() {
        console.log('on open websocket...');
        var x_title   = "document";
        var x_title_tags = document.getElementsByTagName('title');
        if (x_title_tags.length > 0) {
            x_title   = x_title_tags[0].innerHTML;
        }
        var x_body    = document.body;
        var x_json    = {"initialize": x_body.innerHTML, "args": g_eezz_arguments, 'title': x_title};
        g_eezz_web_socket.send(JSON.stringify(x_json));
    }
    
    /* Error handling: Reopen connection */
    g_eezz_web_socket.onerror = function(a_error) {
        console.log('error on websocket ...');
        window.console.error(a_error);
    }

    /* Wait for the application and update the document          */
    g_eezz_web_socket.onmessage = function(a_event) {
        var x_json = JSON.parse(a_event.data)

        // The main response is an update request
        if (x_json.update) {
            console.log('update  ');
            var x_array_descr = x_json.update;
            var x_element_map = new Map();

            for (var i = 0; i < x_array_descr.length; i++) {
                console.log("update " + x_array_descr[i]);
                var x_update_json = x_array_descr[i];

                try { // Abstract function to overwrite for user callback
                    var x_dest = x_update_json.target.split('.'); 
                    if (!x_element_map.has(x_dest[0])) {
                        x_element_map.set(x_dest[0], x_dest[0]);
                    }
                    dynamic_update(x_update_json);
                } catch(err) {
                    console.log("error " + err);
                }
            }

            // call update once per affected root element
            x_element_map.forEach((_value, key) => {
                eezz.on_update(key);
            })
        }

        // The backend might send events. The main event is the init-event, which is the response to the
        // initialization request. The idea is to put all long lasting methods into this loop, so that the
        // HTML page is not blocked at the first call.
        //if (x_json.event) {
        //    if (x_json.event == 'init') {
        //        for (x_element in x_list) {
        //        g_eezz_web_socket.send(x_element.getAttribute('data-eezz-init'));
        //    }
        //}
    }
}

// Dynamic update: The inner-HTML of the element is calculated by the server
// The result is send via WEB socket as json = {tag-name: html, ...}
function dynamic_update(a_update_json) {
    var x_dest      = a_update_json.target.split('.'); 
    var x_attr      = x_dest.pop();
    var x_elem_root = document.getElementById(x_dest[0]);
    var x_elem      = x_elem_root;

    // The following makes sense for table.tbody and table.tfooter etc...
    // In any other cases the update should be more specific
    for (var i = 1; i < x_dest.length && x_elem != null; i++) {
        x_elem = x_elem.getElementsByTagName(x_dest[i])[0];
    } 
    
    if (x_elem == null) { 
        return;
    }
     
    if (x_attr == 'innerHTML') {
        x_elem.innerHTML = a_update_json.value;
    }
    else if (x_attr == 'subtree') {
        tree_expand(x_elem, a_update_json.value)
    }
    else {
        x_elem.setAttribute(x_attr, a_update_json.value);
    }    
}

// Collapse a tree element
function tree_collapse(a_node_element) {
	var x_subtree_state = a_node_element.getAttribute('data-eezz-subtree_state');
	if (x_subtree_state == 'expanded') {
    	// Restore the original entry of the tree node
		var x_subtree_header     = a_node_element.querySelector('thead')
		a_node_element.innerHTML = x_subtree_header.innerHTML;
		a_node_element.setAttribute('data-eezz-subtree_state', 'collapsed');
	}
}

// Inserts a sub-tree into a tree <TR> element, which is defined a given element id
// The constrains are: subtree.tagName is table, and it contains a thead and a tbody
function tree_expand(a_node_element, a_subtree) {
    // Make sure, that the tree node is collapsed and save the node entry as table header entry
	tree_collapse(x_node_element);
	var x_nr_columns = x_node_element.getElementsByTagName('td').length.toString()

    // The thead stores the current row elements
	var x_new_head       = document.createElement('thead');
	x_new_head.innerHTML = a_node_element.outerHTML;
    x_new_head.setAttribute('class', 'clzz_tree_node_head');

	// The tbody contains the subtree
	var x_new_body       = document.createElement('tbody');
    x_new_body.innerHTML = a_subtree;
    x_new_body.setAttribute('class', 'clzz_tree_node_body');

    // The table collects and maintains thead and tbody
	var x_new_tree       = document.createElement('table');
    x_new_tree.appendChild(x_new_head);
    x_new_tree.appendChild(x_new_body);

    // The original cell content is deleted and replaced with the table above
	var x_new_cell       = document.createElement('td');
    x_new_cell.setAttribute('colspan', x_nr_columns);
    x_new_cell.setAttribute('class', 'clzz_tree_node');
    x_new_cell.appendChild(x_new_tree);

	x_node_element.innerHTML  = '';
    x_node_element.appendChild(x_new_cell)
    a_node_element.setAttribute('data-eezz-subtree_state', 'expanded');
}

// Function collects all eezz events from page using WEB-socket to
// send a request to the server
function eezzy_click(aEvent, aElement) {
    var x_post     = true;
    var x_response = "";
    var x_json     = JSON.parse(aElement.getAttribute('data-eezz-json'));

    if (!x_post) {
        return;
    }
    // Generated elements: Return without modifications
    if (aElement.hasAttribute('data-eezz-template')) {
        x_response = JSON.stringify(x_json);
        g_eezz_web_socket.send(x_response);
        return;
    }

    // User form elements: Collect the input data of this page.
    // The syntax for collection is as follows
    // function( key = "id-of-element"."attribute-of-element", ... )
    var x_args = x_json.args
    for (x_key in x_args) {
        var x_split   = x_args.x_key.split('.');
        if (x_split.length != 2) {
            continue;
        }
        var x_element = document.getElementById(x_split[0]);
        if (x_element == null) {
            continue;
        }
        x_args.x_key  = x_element.getAttribute(x_split[1]);
    }
    x_response = JSON.stringify(x_json);
    g_eezz_web_socket.send(x_response);
}
